import * as admin from 'firebase-admin';
// Note: faker is optional - only needed if running seed script
// This file is a script, not a Firebase Function, so it won't be deployed
let faker: any;
try {
    faker = require('@faker-js/faker');
} catch (e) {
    // faker not installed - script won't work but won't break build
    faker = {
        helpers: { arrayElement: (arr: any[]) => arr[0] },
        commerce: { department: () => 'Production' },
        company: { buzzPhrase: () => 'Project' },
        datatype: { boolean: () => false }
    };
}

// Initialize Firebase Admin (relies on ADC or Environment Variables)
if (admin.apps.length === 0) {
    admin.initializeApp();
}

const db = admin.firestore();

// Roles that can be managers
const MANAGER_ROLES = [
    'ADMIN', 'EXEC', 'MANAGER', 'PRODUCER', 'LINE_PRODUCER',
    'POST_PRODUCTION_SUPERVISOR', 'MEDIA_MANAGER', 'POST_COORDINATOR',
    'SUPERCOORDINATOR', 'POST_PRODUCER', 'ASSOCIATE_PRODUCER',
    'DIRECTOR', 'ART_DIRECTOR', 'ASSIST_DIRECTOR'
];

// Seed Function
async function seedTimecardData() {
    console.log('üå± Starting Timecard Seed...');

    try {
        // 1. Fetch all users
        console.log('Fetching users...');
        const usersSnapshot = await db.collection('users').get();

        if (usersSnapshot.empty) {
            console.error('‚ùå No users found in database. Cannot seed timecards/relations.');
            process.exit(1);
        }

        const users = usersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as any));
        console.log(`‚úÖ Found ${users.length} users.`);

        // 2. Identify potential managers
        const potentialManagers = users.filter(u =>
            u.role && MANAGER_ROLES.includes(u.role.toUpperCase())
        );
        console.log(`‚úÖ Identified ${potentialManagers.length} potential managers.`);

        if (potentialManagers.length === 0) {
            console.warn('‚ö†Ô∏è No users with manager roles found. Using ALL users as potential managers.');
            potentialManagers.push(...users);
        }

        const batchSize = 400; // Limits: 500 per batch
        let batch = db.batch();
        let operationCount = 0;

        async function commitBatchIfNeeded() {
            if (operationCount >= batchSize) {
                await batch.commit();
                batch = db.batch();
                operationCount = 0;
                console.log('üíæ Batch committed.');
            }
        }

        // 3. Clear existing Direct Reports (Optional? Maybe risky. Let's append/overwrite if exists)
        // For now, we will just create if not exists to avoid duplicates if run multiple times?
        // User asked to "create ... giving them proper direct reports", implying a full setup.
        // Let's iterate users and ensure they have a direct report entry.

        console.log('Please wait, generating relationships and timecards...');

        for (const user of users) {
            // --- A. Direct Report Relationship ---
            // Decide if this user needs a manager. Everyone except maybe the Owner/SuperAdmin.
            // For simplicity, everyone gets a manager (randomly selected from pool, excluding self).

            const potentialUserManagers = potentialManagers.filter(m => m.id !== user.id);

            if (potentialUserManagers.length > 0) {
                // Check if report already exists? To be safe, we query. 
                // But for "Seed data", querying in a loop is slow. 
                // We'll optimistically create a new doc with a deterministic ID or just random.
                // Let's use a deterministic ID: report_${user.id} to avoid dupes across runs.

                const manager = faker.helpers.arrayElement(potentialUserManagers);
                const reportId = `report_${user.id}`;
                
                const reportData = {
                    employeeId: user.id,
                    managerId: manager.id,
                    organizationId: user.organizationId || 'org_default', // Fallback
                    department: user.department || faker.commerce.department(),
                    project: faker.company.buzzPhrase(),
                    canApproveTimecards: true,
                    canApproveOvertime: faker.datatype.boolean(),
                    requiresEscalation: false,
                    assignmentReason: 'Seeded Relationship',
                    notes: 'Auto-generated by seed script',
                    isActive: true,
                    assignedBy: 'system_seed',
                    effectiveDate: admin.firestore.Timestamp.now(),
                    createdAt: admin.firestore.Timestamp.now(),
                    updatedAt: admin.firestore.Timestamp.now()
                };

                // üî• PRIMARY: Create in userDirectReports collection (matching production workflow system)
                const userDirectReportRef = db.collection('userDirectReports').doc(reportId);
                batch.set(userDirectReportRef, reportData);
                
                // Also create in directReports for backward compatibility
                const directReportRef = db.collection('directReports').doc(reportId);
                batch.set(directReportRef, reportData);
                
                operationCount += 2; // Count both operations
            }

            await commitBatchIfNeeded();

            // --- B. Timecard Entries ---
            // Generate 2 timecards (Current week, Last week)

            const periods = [
                { start: getMonday(new Date()), status: 'draft' }, // Current week
                { start: getMonday(new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)), status: getRandomStatus() } // Last week
            ];

            for (const period of periods) {
                const timecardId = `tc_${user.id}_${period.start.toISOString().split('T')[0]}`;
                const timecardRef = db.collection('timecards').doc(timecardId);

                // Generate Daily Entries
                const entries = [];
                let totalRegular = 0;
                let totalOvertime = 0;
                let totalDoubleTime = 0;

                for (let i = 0; i < 5; i++) { // Mon-Fri
                    const date = new Date(period.start);
                    date.setDate(date.getDate() + i);

                    const hours = faker.number.float({ min: 8, max: 12, multipleOf: 0.5 });
                    const regular = Math.min(hours, 8);
                    const overtime = Math.max(0, Math.min(hours - 8, 4));
                    const doubleTime = Math.max(0, hours - 12); // unlikely with max 12 but logic holds

                    entries.push({
                        id: faker.string.uuid(),
                        date: date.toISOString().split('T')[0],
                        timeIn: '09:00',
                        timeOut: '18:00', // Approx
                        mealIn: '13:00',
                        mealOut: '14:00',
                        totalHours: hours,
                        regularHours: regular,
                        overtimeHours: overtime,
                        doubleTimeHours: doubleTime,
                        project: faker.company.buzzNoun(),
                        activity: 'Development',
                        description: faker.lorem.sentence()
                    });

                    totalRegular += regular;
                    totalOvertime += overtime;
                    totalDoubleTime += doubleTime;
                }

                batch.set(timecardRef, {
                    userId: user.id,
                    organizationId: user.organizationId || 'org_default',
                    weekStartDate: period.start.toISOString().split('T')[0],
                    status: period.status,
                    entries: entries,
                    stats: {
                        totalRegularHours: totalRegular,
                        totalOvertimeHours: totalOvertime,
                        totalDoubleTimeHours: totalDoubleTime,
                        totalHours: totalRegular + totalOvertime + totalDoubleTime
                    },
                    approvals: period.status === 'approved' ? [{
                        approverId: 'system_seed',
                        status: 'approved',
                        timestamp: admin.firestore.Timestamp.now()
                    }] : [],
                    history: [{
                        action: 'created',
                        actorId: 'system_seed',
                        timestamp: admin.firestore.Timestamp.now(),
                        details: 'Seeded timecard'
                    }],
                    createdAt: admin.firestore.Timestamp.now(),
                    updatedAt: admin.firestore.Timestamp.now()
                }, { merge: true });

                operationCount++;
                await commitBatchIfNeeded();
            }
        }

        if (operationCount > 0) {
            await batch.commit();
            console.log('üíæ Final batch committed.');
        }

        console.log('‚úÖ Seed completed successfully!');
        process.exit(0);

    } catch (error) {
        console.error('‚ùå Error seeding data:', error);
        process.exit(1);
    }
}

// Helpers
function getMonday(d: Date) {
    d = new Date(d);
    const day = d.getDay(),
        diff = d.getDate() - day + (day == 0 ? -6 : 1); // adjust when day is sunday
    const monday = new Date(d.setDate(diff));
    monday.setHours(0, 0, 0, 0);
    return monday;
}

function getRandomStatus() {
    const statuses = ['draft', 'submitted', 'approved', 'rejected', 'needs_revision'];
    return faker.helpers.arrayElement(statuses);
}

// Execute
seedTimecardData();
